# This file implements a demo where the user can draw seeds in one canvas
# and see their Voronoi diagram in another canvas. Seeds have randomly
# generated (pink-ish) colors.

namespace CanvasDrawController {
    const dotRadius = 2
}

class CanvasDrawController {
    const _inputCanvas HTMLCanvasElement
    const _outputCanvas HTMLCanvasElement
    const _ctx CanvasRenderingContext2D
    const _onDraw fn()

    const _mouseBehaviorManager = MouseBehaviorManager.new

    # onDraw will be called whenever the user draws something in the canvas.
    # Useful since we want to re-compute the Voronoi diagram of the canvas
    # every time the user draws.
    def new(inputCanvas HTMLCanvasElement, outputCanvas HTMLCanvasElement, onDraw fn()) {
        _inputCanvas = inputCanvas
        _outputCanvas = outputCanvas
        _onDraw = onDraw

        _ctx = _inputCanvas.getContext2D
        _ctx.scale(Browser.powerOfTwoLessThanDevicePixelRatio, Browser.powerOfTwoLessThanDevicePixelRatio)

        _mouseBehaviorManager.listenOnElement(_inputCanvas)
        _mouseBehaviorManager.listenOnElement(_outputCanvas)

        var tempPair = [Vector.new(0, 0), Vector.new(0, 0)]
        
        _mouseBehaviorManager.onDown((e MouseEvent) => {
            if e.target == _inputCanvas || e.target == _outputCanvas {
              tempPair = [e.location, e.location]
            }
        })


        _mouseBehaviorManager.onMove((e MouseEvent) => {

            if e.isDown {
                tempPair = _drawPair(e.location, tempPair)
            }
        })

    }

    def _drawPoint(p Vector, c Color) {
        _ctx.beginPath
        _ctx.rect(
            (p.x - dotRadius) as int,
            (p.y - dotRadius) as int,
            dotRadius * 2,
            dotRadius * 2
        )
        _ctx.fillStyle = c.toCSS
        _ctx.fill
    }

    def _drawPair(outer Vector, prior List<Vector>) List<Vector> {
        const canvasRect = _inputCanvas.getBoundingClientRect
        const canvasShape = Vector.new(canvasRect.width,canvasRect.height)
        
        const colorA = Color.new(0.5, 0.2, 0.3, 1.0)
        const colorB = Color.new(0.3, 0.5, 0.2, 1.0)
        const clockwise double = -Math.PI/2
        const thickness  double = 10
        const delta double = 10

        if !outer.clip(canvasShape) {
            return prior
        }

        # Distance to last point on curve
        var outerPath = prior[0] - outer
        if outerPath.length > delta {
            _drawPoint(outer, colorA)
            prior[0] = outer

            # Get surface normal of line drawn 
            var surface = outerPath.rotated(clockwise).normalize
            var inner = outer + surface * thickness
            var innerPath = prior[1] - inner

            if inner.clip(canvasShape) && innerPath.length > delta {
                _drawPoint(inner, colorB)
                prior[1] = inner
            }

            if _onDraw != null {
                _onDraw()
            }
        }
        return prior
    }
}

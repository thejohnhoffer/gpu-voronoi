# This file implements a demo where the user can draw seeds in one canvas
# and see their Voronoi diagram in another canvas. Seeds have randomly
# generated (pink-ish) colors.

namespace CanvasDrawController {
    const colorA = Color.new(0.5, 0.2, 0.3, 1.0)
    const colorB = Color.new(0.3, 0.5, 0.2, 1.0)
    const clockwise double = -Math.PI/2
    const centerDelta double = 10
    const edgeDelta double = 20
    const thickness  double = 40
    const dotDelta double = 20
}

class CanvasDrawController {
    const _inputCanvas HTMLCanvasElement
    const _outputCanvas HTMLCanvasElement
    const _ctx CanvasRenderingContext2D
    const _onDraw fn()

    const _mouseBehaviorManager = MouseBehaviorManager.new

    # onDraw will be called whenever the user draws something in the canvas.
    # Useful since we want to re-compute the Voronoi diagram of the canvas
    # every time the user draws.
    def new(inputCanvas HTMLCanvasElement, outputCanvas HTMLCanvasElement, onDraw fn()) {
        _inputCanvas = inputCanvas
        _outputCanvas = outputCanvas
        _onDraw = onDraw

        _ctx = _inputCanvas.getContext2D
        _ctx.scale(Browser.powerOfTwoLessThanDevicePixelRatio, Browser.powerOfTwoLessThanDevicePixelRatio)

        _mouseBehaviorManager.listenOnElement(_outputCanvas)

        var tempPair = [Vector.new(0, 0), Vector.new(0, 0)]
        var editing = false
        var moving = false
        
        _mouseBehaviorManager.onDown((e MouseEvent) => {
            if e.target == _outputCanvas {
                tempPair = [e.location, e.location]
            }
        })

        _mouseBehaviorManager.onUp((e MouseEvent) => {
            if !moving && e.target == _outputCanvas {
                editing = !editing
            }
            moving = false
        })
        
        _mouseBehaviorManager.onMove((e MouseEvent) => {

            if e.isDown {
                tempPair = _drawPair(e.location, tempPair, true)
            }
            else if editing {
                tempPair = _drawPair(e.location, tempPair, false)
            }
            moving = true 
        })

    }

    def _drawPoint(p Vector, c Color, split bool) {
        _ctx.clearRect(
            (p.x - dotDelta) as int,
            (p.y - dotDelta) as int,
            dotDelta * 2,
            dotDelta * 2
        )
        if !split {
          return
        }
        _ctx.beginPath
        _ctx.rect(p.x as int, p.y as int, 1, 1)
        _ctx.fillStyle = c.toCSS
        _ctx.fill
    }

    def _drawPair(center Vector, prior List<Vector>, split bool) List<Vector> {
        const canvasRect = _inputCanvas.getBoundingClientRect
        const canvasShape = Vector.new(canvasRect.width,canvasRect.height)
        
        var canDraw = false
        
        if !center.clip(canvasShape) {
            return prior
        }

        # User input path
        var priorCenter = (prior[0] + prior[1]) / 2
        var centerPath = priorCenter - center

        if centerPath.length <= centerDelta {
            return prior
        }

        # New points at right angles to input path
        var outerSurface = centerPath.rotated(-clockwise).normalize
        var innerSurface = centerPath.rotated(clockwise).normalize
        var outer = center + outerSurface * thickness /2
        var inner = center + innerSurface * thickness /2

        if outer.clip(canvasShape){
            if (prior[0] - outer).length > edgeDelta {
                _drawPoint(outer, colorA, split)
                prior[0] = outer
                canDraw = true
            }
        }

        if inner.clip(canvasShape){
            if  (prior[1] - inner).length > edgeDelta {
                _drawPoint(inner, colorB, split)
                prior[1] = inner
                canDraw = true
            }
        }

        if canDraw && _onDraw != null {
            _onDraw()
        }
        return prior
    }
}
